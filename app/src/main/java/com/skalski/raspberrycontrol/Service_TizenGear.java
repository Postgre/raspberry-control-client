/*     * Copyright (c) 2014 Samsung Electronics Co., Ltd. * Copyrigth (c) 2014 Lukasz Skalski <lukasz.skalski@op.pl> * All rights reserved.    *    * Redistribution and use in source and binary forms, with or without    * modification, are permitted provided that the following conditions are    * met:    *    *     * Redistributions of source code must retain the above copyright    *        notice, this list of conditions and the following disclaimer.   *     * Redistributions in binary form must reproduce the above   *       copyright notice, this list of conditions and the following disclaimer   *       in the documentation and/or other materials provided with the   *       distribution.   *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its   *       contributors may be used to endorse or promote products derived from   *       this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.skalski.raspberrycontrol;import java.io.ByteArrayInputStream;import java.io.IOException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.HashMap;import javax.security.cert.X509Certificate;import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.Signature;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Binder;import android.os.IBinder;import android.util.Log;import android.widget.Toast;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class Service_TizenGear extends SAAgent {	public static final String LOGTAG = "RaspberryControl";    private static final String LOGPREFIX = "GEAR_TIZEN: ";    private Custom_WebSocketClient client;	public Context mContext = null;    private final IBinder mBinder = new LocalBinder();	HashMap<Integer, RaspberryControlProviderConnection> mConnectionsMap = null;	public class LocalBinder extends Binder {		public Service_TizenGear getService() {			return Service_TizenGear.this;		}	}	public Service_TizenGear() {		super(LOGTAG, RaspberryControlProviderConnection.class);	}    /*     * Service_TizenGear - RaspberryControlProviderConnection class     */	public class RaspberryControlProviderConnection extends SASocket {		private int mConnectionId;		public RaspberryControlProviderConnection() {			super(RaspberryControlProviderConnection.class.getName());		}		@Override		public void onError(int channelId, String errorString, int error) {            //TODO: Show toast		}		@Override		public void onReceive(int channelId, byte[] data) {			String strData = new String(data);            Log.i (LOGTAG, "RECEIVED " + strData);            /* http://stackoverflow.com/questions/2272378/android-using-method-from-a-service-in-an-activity */            send ("{\"Revision\": \"000f\", \"GPIOState\": [{\"value\": 1, \"gpio\": 9, \"direction\": \"in\"}, {\"value\": 0, \"gpio\": 11, \"direction\": \"in\"}]}");		}        @Override        protected void onServiceConnectionLost(int errorCode) {            Log.i (LOGTAG, "ConnectionLost");            if (mConnectionsMap != null) {                mConnectionsMap.remove(mConnectionId);            }        }        public void send (String msg) {            Log.i (LOGTAG, "TAG");            final String message = msg;            final RaspberryControlProviderConnection uHandler = mConnectionsMap                    .get(Integer.parseInt(String.valueOf(mConnectionId)));            if (uHandler == null) {                Log.e (LOGTAG, "ERROR");                return;            }            new Thread(new Runnable() {                public void run() {                    try {                        uHandler.send(104,message.getBytes());                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }).start();        }	}    /*     * Service_TizenGear - onCreate()     */    @Override    public void onCreate() {        super.onCreate();        SA mAccessory = new SA();        try {        	mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {        } catch (Exception e1) {            e1.printStackTrace();            stopSelf();        }    }    /*     * Service_TizenGear - onServiceConnectionRequested()     */    @Override     protected void onServiceConnectionRequested (SAPeerAgent peerAgent) {        client = ((Custom_WebSocketClient) getApplicationContext());        if (client.isConnected()) {            Log.i (LOGTAG, "LOG1");            acceptServiceConnectionRequest(peerAgent);        } else {            if (client.connect()) {                Log.i (LOGTAG, "LOG2");                acceptServiceConnectionRequest(peerAgent);            } else {                Log.e (LOGTAG, "no connection to the server");            }        }        acceptServiceConnectionRequest(peerAgent);        Toast.makeText(getBaseContext(), "LOG3", Toast.LENGTH_SHORT).show();        //disable application    }    /*     * Service_TizenGear - onAuthenticationResponse()     */    protected void onAuthenticationResponse(SAPeerAgent uPeerAgent, SAAuthenticationToken authToken, int error) {				if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {			mContext = getApplicationContext();			byte[] myAppKey = getApplicationCertificate(mContext);			if (authToken.getKey() != null) {				boolean matched = true;				if(authToken.getKey().length != myAppKey.length){					matched = false;				}else{					for(int i=0; i<authToken.getKey().length; i++){						if(authToken.getKey()[i]!=myAppKey[i]){							matched = false;						}					}				}								if (matched) {					acceptServiceConnectionRequest(uPeerAgent);				}							}		} else if (authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_NONE) 			Log.w (LOGTAG, "onAuthenticationResponse : CERT_TYPE(NONE)");	}    /*     * Service_TizenGear - getApplicationCertificate()     */	private static byte[] getApplicationCertificate(Context context) {		if(context == null) {			return null;		}		Signature[] sigs;		byte[] certificat = null;		String packageName = context.getPackageName();		if (context != null) {			try {				PackageInfo pkgInfo = null;				pkgInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);				if (pkgInfo == null) {					return null;				}				sigs = pkgInfo.signatures;				if (sigs == null) {				} else {					CertificateFactory cf = CertificateFactory.getInstance("X.509");					ByteArrayInputStream stream = new ByteArrayInputStream(sigs[0].toByteArray());					X509Certificate cert;					cert = X509Certificate.getInstance(stream);					certificat = cert.getPublicKey().getEncoded();				}			} catch (NameNotFoundException e) {				e.printStackTrace();			} catch (CertificateException e) {				e.printStackTrace();			} catch (javax.security.cert.CertificateException e) {				e.printStackTrace();			}		}		return certificat;	}    /*     * Service_TizenGear - onFindPeerAgentResponse()     */	@Override	protected void onFindPeerAgentResponse(SAPeerAgent arg0, int arg1) {	}    /*     * Service_TizenGear - onServiceConnectionResponse()     */	@Override	protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket thisConnection, int result) {		if (result == CONNECTION_SUCCESS) {						if (thisConnection != null) {                RaspberryControlProviderConnection myConnection = (RaspberryControlProviderConnection) thisConnection;				if (mConnectionsMap == null) {					mConnectionsMap = new HashMap<Integer, RaspberryControlProviderConnection>();				}				myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);				mConnectionsMap.put(myConnection.mConnectionId, myConnection);			} 		}		else if (result == CONNECTION_ALREADY_EXIST) {			Log.w (LOGTAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");		}	}    /*     * Service_TizenGear - onBind()     */	@Override	public IBinder onBind(Intent arg0) {		return mBinder;	}}